/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-undef */

import { BadRequestException, Injectable, OnModuleInit } from '@nestjs/common';
import { Name } from '<%= orgName %>/app-core';
import { mapArrayWithConcurrency } from '@xystemize/app-core';
import { FirestoreTransaction } from '@xystemize/backend';
import { firestore } from 'firebase-admin';
import { chunk, filter, first, isEmpty, uniq, without } from 'lodash';

import { RequestConfig } from '../../constant';
import { FirestoreDocumentType } from '../../type';
import { FirebaseService } from '../firebase/FirebaseService';

@Injectable()
export class FirestoreService implements OnModuleInit {
  firestore: firestore.Firestore = FirebaseService.firestore;

  get batch(): firestore.WriteBatch {
    return this.firestore.batch();
  }

  get accounts(): firestore.CollectionReference {
    return this.firestore.collection(Name.accounts);
  }

  get mediaItems(): firestore.CollectionReference {
    return this.firestore.collection(Name.mediaItems);
  }

  async onModuleInit() {
    this.firestore = FirebaseService.firestore;
  }

  getOneById = async <T extends { new (...args: any[]): InstanceType<T> }>({
    id,
    collectionName,
    classModel,
  }: {
    id: string;
    collectionName: string;
    classModel: T;
  }): Promise<{
    data: InstanceType<T> | null;
    document: firestore.DocumentSnapshot;
    docRef: firestore.DocumentReference;
  }> => {
    const docRef = this.firestore.collection(collectionName).doc(id);
    const document = await docRef.get();

    if (!document.exists) {
      return { docRef, document, data: null };
    }

    const data = new classModel(document.data());

    return { docRef, document, data };
  };

  getOneByProperty = async <T extends { new (...args: any[]): InstanceType<T> }>({
    value,
    property,
    collectionName,
    classModel,
    visibilityId,
  }: {
    value: string | number | boolean;
    property: string;
    visibilityId?: number;
    collectionName: string;
    classModel: T;
  }): Promise<{
    data: InstanceType<T> | null;
    document?: firestore.DocumentSnapshot | null;
    docRef?: firestore.DocumentReference | null;
  }> => {
    let query = this.firestore.collection(collectionName).where(property, '==', value);

    if (visibilityId) {
      query = query.where(Name.visibilityId, '==', visibilityId);
    }

    query = query.limit(1);

    const documents = await query.get();
    const document = first(documents.docs);

    if (!document?.exists) {
      return { docRef: document?.ref, document, data: null };
    }

    const data = new classModel(document.data());

    return { docRef: document?.ref, document, data };
  };

  getOneByIdandProperty = async <T extends { new (...args: any[]): InstanceType<T> }>({
    id,
    value,
    property,
    collectionName,
    classModel,
    visibilityId,
  }: {
    id: string;
    value: string | number | boolean;
    property: string;
    visibilityId?: number;
    collectionName: string;
    classModel: T;
  }): Promise<{
    data: InstanceType<T> | null;
    document?: firestore.DocumentSnapshot | null;
    docRef?: firestore.DocumentReference | null;
  }> => {
    let query = this.firestore
      .collection(collectionName)
      .where(Name.id, '==', id)
      .where(property, '==', value)
      .where(Name.visibilityId, '==', visibilityId);

    if (query) {
      query = query.where(Name.visibilityId, '==', visibilityId);
    }

    query = query.limit(1);

    const documents = await query.get();
    const document = first(documents.docs);

    if (!document?.exists) {
      return { docRef: document?.ref, document, data: null };
    }

    const data = new classModel(document.data());

    return { docRef: document?.ref, document, data };
  };

  getManyByProperty = async <T extends { new (...args: any[]): InstanceType<T> }>({
    value,
    property,
    collectionName,
    classModel,
    visibilityId,
  }: {
    value: string | number | boolean;
    property: string;
    visibilityId?: number;
    collectionName: string;
    classModel: T;
  }): Promise<Array<InstanceType<T>>> => {
    let query = this.firestore
      .collection(collectionName)
      .where(property, '==', value);

    if (visibilityId) {
      query = query.where(Name.visibilityId, '==', visibilityId);
    }

    const snapshots = await query.get();

    if (!snapshots.docs.length) {
      return [];
    }

    return snapshots.docs.map((obj) => new classModel(obj.data()));
  };

  getManyByIds = async <T extends { new (...args: any[]): InstanceType<T> }>({
    itemIds,
    collectionName,
    classModel,
  }: {
    itemIds: string[];
    collectionName: string;
    classModel: T;
  }): Promise<Array<InstanceType<T>>> => {
    itemIds = uniq(without(itemIds, undefined, null, '') as []);

    if (isEmpty(itemIds)) {
      return [];
    }

    const docRefs = itemIds.map((id) => this.firestore.collection(collectionName).doc(id));
    const documents = await this.firestore.getAll(...docRefs);

    if (!documents.length) {
      return [];
    }

    const items = documents.map((document) => {
      return new classModel(document.data());
    });

    return filter(items, { isValid: true }) as Array<InstanceType<T>>;
  };

  runTransaction = async <T>(fn: (transaction: FirestoreTransaction) => Promise<T>) => {
    const transaction = new FirestoreTransaction();
    await fn(transaction);
    
    return this.firestore.runTransaction(async (trx) => {
      transaction.transactions.forEach(({ type, documentRef, data }) => {
        trx[type](documentRef, data);
      });
    });
  };

  runDocumentAddOrUpdateTransaction = async ({ item }: { item: FirestoreDocumentType }) => {
    if (!item?.id) {
      throw new BadRequestException();
    }

    const docRef = this.firestore.collection(item[Name.collectionName]).doc(item.id);

    await this.runTransaction(async (transaction) => {
      transaction.set(item);
    });

    return { docRef, data: item };
  };

  runMultipleDocumentAddOrUpdateTransactions = async ({ items }: { items: Array<FirestoreDocumentType> }) => {
    const response: { itemsCount: number } = { itemsCount: 0 };

    if (!items.length) {
      return response;
    }

    const chunkedItems = chunk(items, RequestConfig.FirestoreTransactionLimit);

    const handler = async (chunkedItems: Array<FirestoreDocumentType>) => {
      const transaction = await this.runTransaction(async (transaction) => {
        chunkedItems.forEach((item) => {
          transaction.set(item);
        });
      });

      response.itemsCount += chunkedItems.length;

      return transaction;
    };

    await mapArrayWithConcurrency(chunkedItems, RequestConfig.DefaultWriteMaxConcurrency, handler);

    return response;
  };
}
